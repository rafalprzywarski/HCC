(ns hcc.ui)
(require 'hcc.system)
(alias 'si 'hcc.system)


(def fonts (atom nil))
(def images (atom nil))
(def ui-state (atom nil))


(defn v2+ [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)])


(defn align-text [text align valign margin [origin-x origin-y] [width height]]
  (let [margin (or margin 0)
        origin-x (cond
                   (= align :center) (+ origin-x (/ width 2))
                   (= align :right) (- (+ origin-x width) margin)
                   :else (+ origin-x margin))
        origin-y (cond
                   (or (= valign :center) (= valign :baseline-center)) (+ origin-y (/ height 2))
                   (= valign :top) (- (+ origin-y height) margin)
                   :else (+ origin-y margin))]
    {:text-anchor (#{:center :right} align :left)
     :text-vanchor (#{:bottom :center :baseline-center :top} valign :baseline)
     :origin [origin-x origin-y]}))


(defn render-shape [palette {:keys [origin color primitives]} state]
  (let [color (palette color)]
    (map (fn [p] (assoc p
                        :color color
                        :origin (v2+ (p :origin [0 0]) origin)))
         primitives)))


(defn render-label [palette
                    {:keys [id origin extents color font text text-color text-align text-valign margin]}
                    {pressed-id :pressed}]
  (let [color (if (and id (= id pressed-id)) :highlight color)
        color (palette color)
        text-color (palette text-color)]
    [{:type :rect
      :origin origin
      :extents extents
      :color color}
     (merge {:type :text
             :font font
             :text text
             :text-color text-color}
            (align-text text text-align text-valign margin origin extents))]))


(defn render-button [palette
                     {[width height] :extents
                      :keys [id origin extents color font text text-color text-align text-valign margin button-style]}
                     {pressed-id :pressed}]
  (let [color (if (and id (= id pressed-id)) :highlight color)
        color (palette color)
        text-color (palette text-color)]
    (if (= button-style :rounded)
      (let [radius (/ height 2)]
        [{:type :arc
          :origin origin
          :extents [radius height]
          :radius radius
          :center [radius radius]
          :color color}
         {:type :arc
          :origin (v2+ origin [(- width radius) 0])
          :extents [radius height]
          :radius radius
          :center [0 radius]
          :color color}
         {:type :rect
          :origin (v2+ origin [radius 0])
          :extents (v2+ extents [(* -2 radius) 0])
          :color color}
         (merge {:type :text
                 :font font
                 :text text
                 :text-color text-color}
                (align-text text text-align text-valign margin (v2+ origin [radius 0]) (v2+ extents [(* -2 radius) 0])))])
      [{:type :rect
        :origin origin
        :extents extents
        :color color}
       (merge {:type :text
               :font font
               :text text
               :text-color text-color}
              (align-text text text-align text-valign margin origin extents))])))


(defn render-top-left-swept [palette
                             {[width height] :extents
                              :keys [origin inner-radius color]}
                             state]
  (let [color (palette color)]
    [{:type :arc
      :origin origin
      :extents [height height]
      :radius height
      :center [height 0]
      :color color}
     {:type :rect
      :origin (v2+ origin [height 0])
      :extents [(- width (+ height inner-radius)) height]
      :color color}
     {:type :rect
      :origin (v2+ origin [(- width inner-radius) inner-radius])
      :extents [inner-radius (- height inner-radius)]
      :color color}
     {:type :arc
      :origin (v2+ origin [(- width inner-radius) 0])
      :extents [inner-radius inner-radius]
      :radius inner-radius
      :center [inner-radius 0]
      :inverted? :true
      :color color}]))


(defn render-image [palette
                    {:keys [origin image anchor vanchor]}
                    state]
  [{:type :image
    :origin origin
    :image image
    :anchor anchor
    :vanchor vanchor}])


(def ui-renderers
  {:shape render-shape
   :label render-label
   :button render-button
   :top-left-swept render-top-left-swept
   :image render-image})


(defn mapcatv [f coll]
  (loop [s (seq coll)
         out []]
    (if s
      (recur (next s) (concati out (f (first s))))
      out)))


(defn render-primitives [palette ui state]
  (mapcatv (fn [elem]
             (when-let [render (ui-renderers (first elem))]
               (render palette (second elem) state)))
           ui))


(def renderers
  {:arc (fn [{[origin-x origin-y] :origin
              [width height] :extents
              [r g b] :color
              [center-x center-y] :center
              :keys [radius inverted?]}]
          (si/arc! origin-x origin-y (+ origin-x width) (+ origin-y height) r g b (+ origin-x center-x) (+ origin-y center-y) radius (if inverted? -1 1)))
   :rect (fn [{[origin-x origin-y] :origin
               [width height] :extents
               [r g b] :color}]
           (si/rect! origin-x origin-y (+ origin-x width) (+ origin-y height) r g b))
   :text (fn [{[origin-x origin-y] :origin
               [tr tg tb ta] :text-color
               :keys [font text text-anchor text-vanchor]}]
           (if @fonts
             (si/text! (@fonts font)
                       text
                       origin-x origin-y
                       ({:center 0, :right 1} text-anchor -1) ({:bottom -1, :center 1, :baseline-center 2, :top 3} text-vanchor 0)
                       tr tg tb (or ta 255))))
   :image (fn [{[origin-x origin-y] :origin
                :keys [image anchor vanchor]}]
            (when @images
              (si/image! (@images image)
                         origin-x origin-y
                         ({:center 0, :right 1} anchor -1)
                         ({:center 0, :bottom 1} vanchor -1))))})


(defn render-scene! [scene]
  (doseq [elem scene]
    ((renderers (:type elem)) elem))
  (si/render!))


(defn get-event! []
  (when-let [event (si/get-event!)]
    (if-let [position (:position event)]
      (assoc event :position [(position 0) (- (- (si/get-display-height) (position 1)) 1)])
      event)))


(defn find-button-by-pos [ui [pos-x pos-y]]
  (loop [s (seq ui)]
    (when s
      (let [[type {:keys [origin extents] :as button}] (first s)
            [origin-x origin-y] origin
            [width height] extents]
        (if (and (= type :button)
                 (not (or (< pos-x origin-x) (< pos-y origin-y)))
                 (< pos-x (+ origin-x width)) (< pos-y (+ origin-y height)))
          button
          (recur (next s)))))))


(defn trigger-event [elem event state]
  (if-let [handle (get elem event)]
    (handle state)
    state))


(defn handle-app-event [state ui event app-state]
  (let [{:keys [type position]} event]
    (cond
        (= type :touch-up) (let [button (find-button-by-pos ui position)]
                             (if (= (:id button) (:pressed state))
                               (trigger-event button :on-click (trigger-event button :on-touch-up app-state))
                               app-state))
        (= type :touch-down) (let [button (find-button-by-pos ui position)]
                               (trigger-event button :on-touch-down app-state))
        (= type :touch-move) (let [button (find-button-by-pos ui position)]
                               (if (not (= (:id button) (:pressed state)))
                                 (trigger-event (get (:indexed state) (:pressed state)) :on-touch-lost app-state)
                                 app-state))
        :else app-state)))


(defn handle-ui-event [state ui event]
  (let [{:keys [type position]} event]
    (cond
      (= type :touch-up) (let [button (find-button-by-pos ui position)]
                           (dissoc state :pressed))
      (= type :touch-down) (let [button (find-button-by-pos ui position)]
                             (assoc state :pressed (:id button)))
      (= type :touch-move) (if (not (= (:id (find-button-by-pos ui position)) (:pressed state)))
                             (dissoc state :pressed)
                             state)
      :else state)))


(defn handle-ui-input! [ui app-state]
  (loop [app-state app-state]
    (if-let [event (get-event!)]
      (let [{:keys [type position]} event
            new-app-state (handle-app-event @ui-state ui event app-state)]
        (swap! ui-state handle-ui-event ui event)
        (recur new-app-state))
      app-state)))


(defn render-ui-scene! [primitives]
  (si/clear!)
  (render-scene! primitives)
  (si/swap-buffers!))


(defn index-elems [elems]
  (reduce1 (fn [indexed elem] (assoc indexed (:id (second  elem)) elem))
           {}
           (filter (fn [elem] (:id (second elem))) elems)))

(defn render-ui-elems [ui state]
  (map
   (fn [[component :as elem]]
     (cond
       (keyword? component) [elem]
       (and (map? component) (::fn component)) ((::fn component)
                                                ((::state-fn component) state) (next elem))))
   ui))


(defn render-ui [ui state]
  (persistent! (reduce1 (fn [out elem]
                          (reduce1 conj! out elem))
                        (transient [])
                        (render-ui-elems ui state))))


(defn step! [palette ui app-state]
  (let [app-state (if-let [rendered (:rendered @ui-state)]
                    (handle-ui-input! rendered app-state)
                    app-state)]
    (let [rendered (render-ui ui app-state)
          indexed (index-elems rendered)
          primitives (render-primitives palette rendered @ui-state)]
      (swap! ui-state (fn [state] (assoc state
                                         :rendered rendered
                                         :indexed indexed)))
      (render-ui-scene! primitives)
      app-state)))


(defmacro defc [name [state-param :as params] body]
  (list 'def name (if (and (map? state-param)
                           (= (count state-param) 1)
                           (contains? state-param :keys))
                    {::fn `(fn [~(:keys state-param) [~@(next params)]] ~body)
                     ::state-fn `(fn state-fn [~state-param] ~(:keys state-param))}
                    {::fn `(fn [~state-param [~@(next params)]] ~body)
                     ::state-fn `(fn [state#] state#)})))


(defn load-fonts! [fs]
  (reset! fonts (reduce1 (fn [out {:keys [name path size]}]
                           (assoc out name (si/load-font path size)))
                         {}
                         fs))
  (println "loaded" (count @fonts) "fonts"))


(defn load-images! [imgs]
  (reset! images (reduce1 (fn [out {:keys [name path]}]
                            (assoc out name (si/load-image path)))
                          {}
                          imgs))
  (println "loaded" (count @images) "images"))


(defn initialize! [scale]
  (si/initialize! scale)
  (println "initialized display" (si/get-display-width) "x" (si/get-display-height)))


(defn shutdown! []
  (si/shutdown!)
  (println "done"))
