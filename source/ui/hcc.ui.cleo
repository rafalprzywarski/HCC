(ns hcc.ui)
(require 'hcc.graphics)
(alias 'g 'hcc.graphics)
(require 'hcc.input)
(alias 'in 'hcc.input)


(def fonts (atom nil))
(def ui-state (atom nil))


(defn v2+ [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)])


(defn align-text [text align valign margin [origin-x origin-y] [width height]]
  (let [margin (or margin 0)
        origin-x (cond
                   (= align :center) (+ origin-x (/ width 2))
                   (= align :right) (- (+ origin-x width) margin)
                   :else (+ origin-x margin))
        origin-y (cond
                   (= valign :center) (+ origin-y (/ height 2))
                   (= valign :top) (- (+ origin-y height) margin)
                   :else (+ origin-y margin))]
    {:text-anchor ({:center :center, :right :right} align :left)
     :text-vanchor ({:center :center, :top :top} valign :bottom) ; TODO: use hash-set
     :origin [origin-x origin-y]}))


(defn render-shape [palette {:keys [origin color primitives]} state]
  (let [color (palette color)]
    (map (fn [p] (assoc p
                        :color color
                        :origin (v2+ (p :origin [0 0]) origin)))
         primitives)))


(defn render-label [palette
                    {:keys [id origin extents color font text text-color text-align text-valign margin]}
                    {{pressed-id :id} :pressed}]
  (let [color (if (and id (= id pressed-id)) :highlight color)
        color (palette color)
        text-color (palette text-color)]
    [{:type :rect
      :origin origin
      :extents extents
      :color color}
     (merge {:type :text
             :font font
             :text text
             :color color
             :text-color text-color}
            (align-text text text-align text-valign margin origin extents))]))


(defn render-rounded-button [palette
                             {[width height] :extents
                              :keys [id origin extents color font text text-color text-align text-valign margin]}
                             {{pressed-id :id} :pressed}]
  (let [color (if (and id (= id pressed-id)) :highlight color)
        color (palette color)
        text-color (palette text-color)
        radius (/ height 2)]
    [{:type :arc
      :origin origin
      :extents [radius height]
      :radius radius
      :center [radius radius]
      :color color}
     {:type :arc
      :origin (v2+ origin [(- width radius) 0])
      :extents [radius height]
      :radius radius
      :center [0 radius]
      :color color}
     {:type :rect
      :origin (v2+ origin [radius 0])
      :extents (v2+ extents [(* -2 radius) 0])
      :color color}
     (merge {:type :text
             :font font
             :text text
             :color color
             :text-color text-color}
            (align-text text text-align text-valign margin (v2+ origin [radius 0]) (v2+ extents [(* -2 radius) 0])))]))


(defn render-top-left-swept [palette
                             {[width height] :extents
                              :keys [origin inner-radius color]}
                             state]
  (let [color (palette color)]
    [{:type :arc
      :origin origin
      :extents [height height]
      :radius height
      :center [height 0]
      :color color}
     {:type :rect
      :origin (v2+ origin [height 0])
      :extents [(- width (+ height inner-radius)) height]
      :color color}
     {:type :rect
      :origin (v2+ origin [(- width inner-radius) inner-radius])
      :extents [inner-radius (- height inner-radius)]
      :color color}
     {:type :arc
      :origin (v2+ origin [(- width inner-radius) 0])
      :extents [inner-radius inner-radius]
      :radius inner-radius
      :center [inner-radius 0]
      :inverted? :true
      :color color}]))


(def ui-renderers
  {:shape render-shape
   :label render-label
   :rounded-button render-rounded-button
   :top-left-swept render-top-left-swept})


(defn mapcatv [f coll]
  (loop [s (seq coll)
         out []]
    (if s
      (recur (next s) (concati out (f (first s))))
      out)))


(defn render-primitives [palette ui state]
  (mapcatv (fn [elem]
             (when-let [render (ui-renderers (:type elem))]
               (render palette elem state)))
           ui))


(def renderers
  {:arc (fn [{[origin-x origin-y] :origin
              [width height] :extents
              [r g b] :color
              [center-x center-y] :center
              :keys [radius inverted?]}]
          (g/arc! origin-x origin-y (+ origin-x width) (+ origin-y height) r g b (+ origin-x center-x) (+ origin-y center-y) radius (if inverted? -1 1)))
   :rect (fn [{[origin-x origin-y] :origin
               [width height] :extents
               [r g b] :color}]
           (g/rect! origin-x origin-y (+ origin-x width) (+ origin-y height) r g b))
   :text (fn [{[origin-x origin-y] :origin
               [tr tg tb ta] :text-color
               [r g b] :color
               :keys [font text text-anchor text-vanchor]}]
           (if @fonts
             (g/text! (@fonts font)
                      text
                      origin-x origin-y
                      ({:center 0, :right 1} text-anchor -1) ({:center 0, :top 1} text-vanchor -1)
                      tr tg tb (or ta 255)
                      r g b)))})


(defn render-scene! [scene]
  (doseq [elem scene]
    ((renderers (:type elem)) elem))
  (g/render!))


(defn get-event! []
  (when-let [event (in/get-event!)]
    (if-let [position (:position event)]
      (assoc event :position [(position 0) (- (- (g/get-display-height) (position 1)) 1)])
      event)))


(defn find-button-by-pos [ui [pos-x pos-y]]
  (loop [s (seq ui)]
    (when s
      (let [{:keys [type origin extents] :as button} (first s)
            [origin-x origin-y] origin
            [width height] extents]
        (if (and (= type :rounded-button)
                 (not (or (< pos-x origin-x) (< pos-y origin-y)))
                 (< pos-x (+ origin-x width)) (< pos-y (+ origin-y height)))
          button
          (recur (next s)))))))


(defn trigger-event [elem event state]
  (if-let [handle (get elem event)]
    (handle state)
    state))


(defn handle-app-event [state ui event app-state]
  (let [{:keys [type position]} event]
    (cond
        (= type :touch-up) (let [button (find-button-by-pos ui position)]
                             (if (= button (:pressed state))
                               (trigger-event button :on-click (trigger-event button :on-touch-up app-state))
                               app-state))
        (= type :touch-down) (let [button (find-button-by-pos ui position)]
                               (trigger-event button :on-touch-down app-state))
        (= type :touch-move) (let [button (find-button-by-pos ui position)]
                               (if (not (= button (:pressed state)))
                                 (trigger-event (:pressed state) :on-touch-lost app-state)
                                 app-state))
        :else app-state)))


(defn handle-ui-event [state ui event]
  (let [{:keys [type position]} event]
    (cond
      (= type :touch-up) (let [button (find-button-by-pos ui position)]
                           (dissoc state :pressed))
      (= type :touch-down) (let [button (find-button-by-pos ui position)]
                             (assoc state :pressed button))
      (= type :touch-move) (if (not (= (find-button-by-pos ui position) (:pressed state)))
                             (dissoc state :pressed)
                             state)
      :else state)))


(defn handle-ui-input! [ui app-state]
  (loop [app-state app-state]
    (if-let [event (get-event!)]
      (let [{:keys [type position]} event
            new-app-state (handle-app-event @ui-state ui event app-state)]
        (swap! ui-state handle-ui-event ui event)
        (recur new-app-state))
      app-state)))


(defn render-ui! [palette ui]
  (g/clear!)
  (render-scene! (render-primitives palette ui @ui-state))
  (g/swap-buffers!))


(defn step! [palette ui app-state]
  (let [app-state (if-let [rendered (:rendered @ui-state)]
                    (handle-ui-input! rendered app-state)
                    app-state)]
    (let [rendered (ui app-state)]
      (swap! ui-state assoc :rendered rendered)
      (render-ui! palette rendered)
      app-state)))


(defn load-fonts! [fs]
  (reset! fonts (reduce1 (fn [out {:keys [name path size]}]
                           (assoc out name (g/load-font path size)))
                         {}
                         fs))
  (println "loaded" (count @fonts) "fonts"))


(defn initialize! []
  (g/initialize!)
  (println "initialized display" (g/get-display-width) "x" (g/get-display-height))
  (in/initialize!))


(defn shutdown! []
  (in/shutdown!)
  (g/shutdown!)
  (println "done"))
